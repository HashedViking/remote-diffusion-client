import {
  app,
  BrowserWindow,
  Menu,
  clipboard,
  ipcMain,
  dialog,
  globalShortcut,
} from "electron";
import settings from "electron-settings";
import * as keytar from "keytar";
import AutoLaunch from "auto-launch";
import * as api from "./api";
import { currentKey } from "./api";
import * as sdwebui from "./sdwebui";
import * as frpc from "./frpc";
import * as filemanager from "./filemanager";
import { ServerStatus } from "./types";
import { ALLOWED_OVERWRITE_KEY, ALLOWED_REMOTE_READ_KEY, FILE_SERVER_FOLDER_PATH_KEY, SD_WEB_UI_SCRIPT_PATH_KEY } from "./settings";

let mainWindow: BrowserWindow | null;
let status: string = "";
let dotsStatus = {
  keyRegistrationStatus: false,
  sdWebUIStatus: false,
  remoteServerStatus: false,
};
let isRemoteServerRunning: boolean = false;
const isDevelopment = process.env.NODE_ENV !== "production";

// This allows TypeScript to pick up the magic constants that's auto-generated by Forge's Webpack
// plugin that tells the Electron app where to look for the Webpack-bundled app code (depending on
// whether you're running in development or production).
declare const MAIN_WINDOW_WEBPACK_ENTRY: string;
declare const MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY: string;

async function createWindow(): Promise<void> {
  return new Promise((resolve) => {
    mainWindow = new BrowserWindow({
      width: 1200,
      height: 1200,
      resizable: true,
      useContentSize: true,
      frame: true,
      webPreferences: {
        preload: MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY,
        contextIsolation: true,
        webSecurity: true
      },
    });

    // mainWindow.removeMenu();

    // and load the index.html of the app.
    mainWindow.loadURL(MAIN_WINDOW_WEBPACK_ENTRY);

    // Open the DevTools.
    // mainWindow.webContents.openDevTools();
    mainWindow.center();

    // const template: Electron.MenuItemConstructorOptions[] = [
    //   {
    //     label: "Application",
    //     submenu: [{ role: "about" }, { type: "separator" }, { role: "quit" }],
    //   },
    // ];

    // const menu = Menu.buildFromTemplate(template);
    // Menu.setApplicationMenu(menu);

    mainWindow.once("ready-to-show", () => {
      resolve();
    });
  });
}

app.on("ready", createWindow);

// Quit when all windows are closed, except on macOS. There, it's common
// for applications and their menu bar to stay active until the user quits
// explicitly with Cmd + Q.
app.on("window-all-closed", () => {
  if (process.platform !== "darwin") {
    app.quit();
  }
});

app.on("activate", () => {
  // On OS X it's common to re-create a window in the app when the
  // dock icon is clicked and there are no other windows open.
  if (BrowserWindow.getAllWindows().length === 0) {
    createWindow();
  }
});

app.whenReady().then(async () => {
  const key = await keytar.getPassword("remote-diffusion", "UserKey");
  api.setCurrentKey(key);
  await checkRegisteredKey();
  checkSDWebUIStatusPeriodically();
  syncWithRemoteServerPeriodically();
  filemanager.checkDownloadJobsPeriodically();
});

// app.whenReady().then(() => {
//   globalShortcut.register("CommandOrControl+R", () => {
//     console.log("Reload shortcut is pressed but action is prevented");
//   });

//   globalShortcut.register("CommandOrControl+Shift+I", () => {
//     console.log("Toggle Developer Tools shortcut is pressed but action is prevented");
//   });
// });

// app.on("window-all-closed", async () => {
//   if (process.platform !== "darwin") {
//     try {
//       exec(`cmd.exe /C "taskkill /IM frpc.exe /F"`);
//       console.log('FRPC client stopped');
//       await axios.post(stopEndpoint, currentKey);
//       console.log('Server stopped');
//     } catch (error) {
//       console.error('An error occurred:', error);
//     }
//     app.quit();
//   }
// });

let isQuitting = false;
app.on("before-quit", async (event) => {
  if (isQuitting) {
    return;
  }

  event.preventDefault();
  isQuitting = true;
  try {
    await stopFrpcClientSilently();
    await stopFrpsServerSilently();
    await stopSDWebUISilently();
  } catch (error) {
    console.error("An error occurred:", error);
  }
  app.quit();
});

async function checkRegisteredKey(): Promise<boolean> {
  const { success, msg } = await api.checkRegisteredKeyRequest(currentKey);
  status = msg;
  sendStatusUpdated(status);
  dotsStatus.keyRegistrationStatus = success;
  sendDotStatusUpdated(dotsStatus);
  return success;
}

ipcMain.on("register-new-key", async () => {
  registerNewKey();
});

async function updateCurrentKey(newKey: string): Promise<void> {
  api.setCurrentKey(newKey);
  keytar.setPassword("remote-diffusion", "UserKey", newKey);
}

async function registerNewKey(): Promise<string> {
  const isNoKeyRegistered = currentKey === "" || currentKey === null;
  status = isNoKeyRegistered
    ? "No key registered. Registering new key..."
    : "Removing old key. Registering new key...";
  sendKeyUpdated(currentKey, status);

  if (!isNoKeyRegistered) {
    await unregisterCurrentKey();
  }

  const { success, msg, key } = await api.registerNewKeyRequest();
  status = msg;
  sendStatusUpdated(status);
  if (success) {
    updateCurrentKey(key);
    sendKeyUpdated(currentKey, status);
    dotsStatus.keyRegistrationStatus = true;
    sendDotStatusUpdated(dotsStatus);
    return currentKey;
  } else {
    console.error(msg);
  }
}

async function unregisterCurrentKey(): Promise<void> {
  status = "Unregistering key...";
  sendStatusUpdated(status);

  const { success, msg } = await api.unregisterKeyRequest();
  status = msg;
  sendStatusUpdated(status);
  if (success) {
    dotsStatus.keyRegistrationStatus = false;
    dotsStatus.remoteServerStatus = false;
    sendDotStatusUpdated(dotsStatus);
  } else {
    console.error(msg);
  }
}

async function stopSDWebUISilently(): Promise<void> {
  const stopResult = await sdwebui.stopSDWebUIRequest();
  if (stopResult.success) {
    console.log("SDWebUI stopped");
  } else {
    console.error("Error stopping SDWebUI: ", stopResult.msg);
  }
}

async function checkSDWebUIStatusPeriodically(): Promise<void> {
  let statusUpdated = false;
  while (true) {
    try {
      const isLocalServerRunning =
        await sdwebui.checkLocalServerStatusRequest();
      if (isLocalServerRunning) {
        if (!statusUpdated) {
          status = "SDWebUI has started";
          sendStatusUpdated(status);
          statusUpdated = true;
        }
      }
      // console.log("Local server is running: ", isLocalServerRunning);
      dotsStatus.sdWebUIStatus = isLocalServerRunning;
      sendDotStatusUpdated(dotsStatus);
    } catch (error) {
      console.error("Error checking SDWebUI status: ", error);
    }
    await new Promise((resolve) => setTimeout(resolve, 5000));
  }
}

async function syncWithRemoteServerPeriodically(): Promise<void> {
  while (true) {
    try {
      const statusUpdated = await checkRemoteServerStatus();
      const isRemoteServerRunningUpdate = statusUpdated.running;
      dotsStatus.remoteServerStatus = isRemoteServerRunningUpdate;
      sendDotStatusUpdated(dotsStatus);
      if (isRemoteServerRunning && !isRemoteServerRunningUpdate) {
        status = "Remote server is not running. Stopping local FRPC server...";
        sendStatusUpdated(status);
        await stopFrpcClient();
        await stopSDWebUI();
        mainWindow?.webContents.send("server-stopped", { status });
      }
      if (!isRemoteServerRunning && isRemoteServerRunningUpdate) {
        status = "Remote server is running";
        sendStatusUpdated(status);
        await restartFrpcClient(
          statusUpdated.bindPort,
          statusUpdated.fileServerPort,
          statusUpdated.token,
          sdwebui.sdWebUIPort
        );
        await reportClientActivity();
        await prepareAndStartSDWebUI();
        mainWindow?.webContents.send("server-started", { status });
      }
      isRemoteServerRunning = isRemoteServerRunningUpdate;
      // console.log("Remote server is running: ", isRemoteServerRunning);
      dotsStatus.remoteServerStatus = isRemoteServerRunning;
      sendDotStatusUpdated(dotsStatus);
    } catch (error) {
      console.error("Error syncing with remote server: ", error);
    }
    await new Promise((resolve) => setTimeout(resolve, 5000));
  }
}

async function prepareAndStartSDWebUI(): Promise<void> {
  status = "Starting SDWebUI...";
  sendStatusUpdated(status);
  const startResult = await sdwebui.prepareAndStartSDWebUIRequest();
  if (startResult.success) {
    status = "SDWebUI started";
    dotsStatus.sdWebUIStatus = true;
    sendDotStatusUpdated(dotsStatus);
  } else {
    console
    status = startResult.msg;
  }
  sendStatusUpdated(status);
}

async function stopSDWebUI(): Promise<void> {
  status = "Stopping SDWebUI";
  sendStatusUpdated(status);
  const stopResult = await sdwebui.stopSDWebUIRequest();
  if (stopResult.success) {
    status = "SDWebUI stopped";
    dotsStatus.sdWebUIStatus = false;
    sendDotStatusUpdated(dotsStatus);
  } else {
    console.error(stopResult.msg);
    status = stopResult.msg;
  }
  sendStatusUpdated(status);
}

async function checkRemoteServerStatus(): Promise<ServerStatus | null> {
  const { data } = await api.checkRemoteServerStatusRequest();
  return data;
}

async function startRemoteServer(sdWebUIPort: number): Promise<void> {
  status = "Starting server...";
  sendStatusUpdated(status);

  await registerKeyIfNotValid();

  const { success, msg, data } = await api.startRemoteServerRequest();
  status = msg;
  sendStatusUpdated(status);
  if (success) {
    frpc.configure(
      data.bindPort,
      data.fileServerPort,
      data.authToken,
      sdWebUIPort
    );
    await startFrpcClient();
    await reportClientActivity();
    setServerStartedStatus();
  }
}

async function restartFrpcClient(
  bindPort: string,
  fileServerPort: string,
  token: string,
  sdWebUIPort: number
): Promise<void> {
  await stopFrpcClient();
  await new Promise((resolve) => setTimeout(resolve, 2000));
  await frpc.configure(bindPort, fileServerPort, token, sdWebUIPort);
  await startFrpcClient();
}

function setServerStartedStatus(): void {
  isRemoteServerRunning = true;
  status = "Server started";
  sendStatusUpdated(status);
  dotsStatus.remoteServerStatus = true;
  sendDotStatusUpdated(dotsStatus);
}

function setServerStoppedStatus(): void {
  isRemoteServerRunning = false;
  status = "Server stopped";
  sendStatusUpdated(status);
  dotsStatus.remoteServerStatus = false;
  sendDotStatusUpdated(dotsStatus);
  mainWindow?.webContents.send("server-stopped", { status });
}

async function startFrpcClient(): Promise<void> {
  frpc.start();
}

frpc.frpcEvents.on("start", ({ success, msg }) => {
  console.log(msg);
});

frpc.frpcEvents.on("exit", ({ success, msg }) => {
  console.log(msg);
});

frpc.frpcEvents.on("error", ({ success, msg }) => {
  console.error(msg);
  setServerStoppedStatus();
});

async function stopFrpcClient(): Promise<void> {
  const { success, msg } = await frpc.stop();
  status = msg;
  sendStatusUpdated(status);
  if (success) {
    console.log(msg);
  } else {
    console.error(msg);
  }
}

async function stopFrpcClientSilently(): Promise<void> {
  const { success, msg } = await frpc.stop();
  if (!success) {
    console.error(msg);
  }
}

async function reportClientActivity(): Promise<void> {
  const { msg } = await api.reportClientActivityRequest();
  status = msg;
  sendStatusUpdated(status);
}

async function stopFrpsServer(): Promise<void> {
  status = "Stopping server...";
  sendStatusUpdated(status);

  const { success, msg } = await api.stopFrpsServerRequest();
  status = msg;
  sendStatusUpdated(status);
  if (success) {
    isRemoteServerRunning = false;
    dotsStatus.remoteServerStatus = false;
    sendDotStatusUpdated(dotsStatus);
  }
}

async function stopFrpsServerSilently(): Promise<void> {
  try {
    await api.stopFrpsServerRequest();
  } catch (error: any) {
    console.error("Error stopping FRPS:", error);
  }
}

function currentKeyIsEmpty(): boolean {
  return currentKey === "" || currentKey === null;
}

async function registerKeyIfNotValid(): Promise<void> {
  const isEmpty = currentKeyIsEmpty();
  const isRegistered = await checkRegisteredKey();
  if (isEmpty || !isRegistered) {
    await registerNewKey();
  }
}

filemanager.events.on("statusUpdated", (status) => {
  console.log(status);
});

ipcMain.on("start-server", async (event) => {
  await registerKeyIfNotValid();
  await prepareAndStartSDWebUI();
  await startRemoteServer(sdwebui.sdWebUIPort);

  event.reply("server-started", { status });
});

ipcMain.on("stop-server", async (event) => {
  await stopFrpcClient();
  await stopFrpsServer();
  await stopSDWebUI();

  event.reply("server-stopped", { status });
});

ipcMain.on("copy-key", () => {
  clipboard.writeText(currentKey);
  mainWindow?.webContents.send("key-copied");
});

ipcMain.on("open-directory-dialog", (event) => {
  dialog
    .showOpenDialog({
      properties: ["openDirectory"],
    })
    .then((result) => {
      if (!result.canceled) {
        const path = result.filePaths[0];
        settings.set(FILE_SERVER_FOLDER_PATH_KEY, path);
        event.reply("selected-directory", path);
      }
    })
    .catch((err) => {
      console.log(err);
    });
});

ipcMain.on("open-file-dialog", (event) => {
  dialog
    .showOpenDialog({
      properties: ["openFile"],
    })
    .then((result) => {
      if (!result.canceled) {
        const path = result.filePaths[0];
        settings.set(SD_WEB_UI_SCRIPT_PATH_KEY, path);
        event.reply("selected-file", path);
      }
    })
    .catch((err) => {
      console.log(err);
    });
});

ipcMain.on("load-path", (event) => {
  const path = settings.get(FILE_SERVER_FOLDER_PATH_KEY, "");
  event.reply("load-path-reply", path);
});

ipcMain.on("load-sdwebui-script-path", (event) => {
  const path = settings.get(SD_WEB_UI_SCRIPT_PATH_KEY, "");
  event.reply("load-sdwebui-script-path-reply", path);
});

ipcMain.on("load-client-key", async (event) => {
  const key = await keytar.getPassword("remote-diffusion", "UserKey");
  event.reply("load-client-key-reply", key);
});

ipcMain.on("load-auth-data", async (event) => {
  const username = await keytar.getPassword("remote-diffusion", "username");
  const password = await keytar.getPassword("remote-diffusion", "password");
  event.reply("load-auth-data-reply", { username, password });
});

ipcMain.on("load-allow-remote-read", (event) => {
  const allowed = settings.get(ALLOWED_REMOTE_READ_KEY, false);
  event.reply("allow-remote-read-reply", allowed);
});

ipcMain.on("load-allow-overwriting", (event) => {
  const allowed = settings.get(ALLOWED_OVERWRITE_KEY, false);
  event.reply("allow-overwriting-reply", allowed);
});

ipcMain.on("set-auth-data", (event, data: any) => {
  keytar.setPassword("remote-diffusion", "username", data.username);
  keytar.setPassword("remote-diffusion", "password", data.password);
});

ipcMain.on("allow-remote-read", (event) => {
  const was = settings.get(ALLOWED_REMOTE_READ_KEY, false);
  settings.set(ALLOWED_REMOTE_READ_KEY, !was);
  event.reply("allow-remote-read-reply", !was);
});

ipcMain.on("allow-overwriting", (event) => {
  const was = settings.get(ALLOWED_OVERWRITE_KEY, false);
  settings.set(ALLOWED_OVERWRITE_KEY, !was);
  event.reply("allow-overwriting-reply", !was);
});

function sendKeyUpdated(key: string, status: string): void {
  mainWindow?.webContents.send("key-updated", { key, status });
}

function sendStatusUpdated(status: string): void {
  mainWindow?.webContents.send("status-updated", { status });
}

function sendDotStatusUpdated(dotsStatus: any): void {
  mainWindow?.webContents.send("dots-changed", dotsStatus);
}

let autoLauncher = new AutoLaunch({
  name: "Remote Diffusion",
  path: app.getPath("exe"),
});

autoLauncher.isEnabled().then((isEnabled: any) => {
  if (!isEnabled && !isDevelopment) autoLauncher.enable();
});

console.log(settings.file());
